/// errcode section
///
/// example: `Section: Class HV - Foreign Data Wrapper Error (SQL/MED)`
///
/// ```rust,ignore
/// let section = Section {
///     class: ['H','V'],
///     name: "Foreign Data Wrapper Error".into(),
///     note: Some("SQL/MED".into()),
/// };
/// ```
#[derive(Debug, Default)]
#[allow(dead_code)]
pub struct Section {
    pub class: [char;2],
    pub name: String,
    pub note: Option<String>,
}

impl PartialEq for Section {
    fn eq(&self, other: &Self) -> bool {
        self.class.eq(&other.class)
    }
}

impl PartialOrd for Section {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.class.cmp(&other.class))
    }
}

impl Eq for Section { }

impl Ord for Section {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.class.cmp(&other.class)
    }
}

#[derive(Debug)]
#[allow(dead_code)]
pub struct ErrCode {
    /// 5 character SQLSTATE conventions
    pub sqlstate: String,
    /// E/W/S
    pub status: String,
    pub name: String,
    pub spec_name: Option<String>,
}

pub struct ErrCodeParser<'a> {
    source: &'a str,
}

impl<'a> ErrCodeParser<'a> {
    pub fn new(source: &'a str) -> Self {
        Self { source }
    }

    pub fn parse(self) -> Vec<ErrCode> {
        let mut output = vec![];

        for line in self.source.lines() {
            if line.starts_with('#')
                || line.starts_with("Section")
                || line.trim().is_empty()
            {
                continue;
            }

            let mut it = line.split_whitespace();
            let sqlstate = it.next().unwrap().to_owned();
            let status = it.next().unwrap().to_owned();
            let name = it.next().unwrap().to_owned();
            let spec_name = it.next().map(str::to_owned);

            output.push(ErrCode { sqlstate, status, name, spec_name, });
        }

        output
    }
}

pub struct ErrCodeGen {
    errcodes: Vec<ErrCode>,
}

const HEADLINE: &[u8] = b"\
//! Autogenerated file from postgres `errcodes.txt`

/// A SQLSTATE error code
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct SqlState(Inner);

impl SqlState {
    /// Create new `SqlState` from error code
    pub fn from_code(s: &str) -> SqlState {{
        match SQLSTATE_MAP.get(s) {
            Some(state) => state.clone(),
            None => SqlState(Inner::Other(s.into())),
        }
    }

    /// Returns the error code corresponding to the `SqlState`
    pub fn code(&self) -> &str {
        match &self.0 {
";

const CODE_END: &[u8] = b"\
            Inner::Other(code) => code,
        }
    }
";

const CONST_END: &[u8] = b"\
}

#[derive(PartialEq, Eq, Clone, Debug)]
#[allow(clippy::upper_case_acronyms)]
enum Inner {\
";

const INNER_END: &[u8] = b"\
    Other(Box<str>)
}

static SQLSTATE_MAP: phf::Map<&'static str, SqlState> = ";

impl ErrCodeGen {
    pub fn new(errcodes: Vec<ErrCode>) -> Self {
        Self { errcodes }
    }

    pub fn codegen<W: std::io::Write>(self, writer: &mut W) -> std::io::Result<()> {
        writer.write_all(HEADLINE)?;

        for ErrCode { sqlstate, .. } in &self.errcodes {
            write!(
                writer,
                "        Inner::E{sqlstate} => \"{sqlstate}\",\n"
            )?;
        }

        writer.write_all(CODE_END)?;

        for ErrCode { sqlstate, name: errcode_macro_name, .. } in &self.errcodes {
            let name = errcode_macro_name.strip_prefix("ERRCODE_").expect("convention");
            write!(
                writer,"
    /// {sqlstate}
    pub const {name}: SqlState = SqlState(Inner::E{sqlstate});"
            )?;
        }

        writer.write_all(CONST_END)?;

        for ErrCode { sqlstate, .. } in &self.errcodes {
            write!(writer, "    E{sqlstate},\n")?;
        }

        writer.write_all(INNER_END)?;

        let mut builder = phf_codegen::Map::new();

        for ErrCode { sqlstate, name: errcode_macro_name, .. } in &self.errcodes {
            let name = errcode_macro_name.strip_prefix("ERRCODE_").expect("convention");
            builder.entry(&**sqlstate, &format!("SqlState::{name}"));
        }

        write!(writer, "{}\n", builder.build())?;

        Ok(())
    }
}


