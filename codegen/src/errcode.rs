#[derive(Debug)]
#[allow(dead_code)]
pub struct ErrCode<'a> {
    /// 5 character SQLSTATE conventions
    pub sqlstate: &'a str,
    /// E/W/S
    pub status: &'a str,
    pub name: &'a str,
    pub spec_name: Option<&'a str>,
}

pub struct ErrCodeParser<'a> {
    source: &'a str,
}

impl<'a> ErrCodeParser<'a> {
    pub fn new(source: &'a str) -> Self {
        Self { source }
    }

    pub fn parse(self) -> Vec<ErrCode<'a>> {
        let mut output = Vec::<ErrCode>::new();

        for line in self.source.lines() {
            if line.starts_with('#')
                || line.starts_with("Section")
                || line.trim().is_empty()
            {
                continue;
            }

            let mut it = line.split_whitespace();
            let sqlstate = it.next().unwrap();
            let status = it.next().unwrap();
            let name = it.next().unwrap().strip_prefix("ERRCODE_").expect("convention");
            let spec_name = it.next();

            if let Some(dup_idx) = output.iter().position(|e|e.sqlstate == sqlstate) {
                output.remove(dup_idx);
            }
            output.push(ErrCode { sqlstate, status, name, spec_name, });
        }

        output
    }
}

pub struct ErrCodeGen<'a> {
    errcodes: Vec<ErrCode<'a>>,
}

impl<'a> ErrCodeGen<'a> {
    pub fn new(errcodes: Vec<ErrCode<'a>>) -> Self {
        Self { errcodes }
    }

    pub fn codegen<W: std::io::Write>(self, writer: &mut W) -> std::io::Result<()> {
        writer.write_all(b"\
//! Autogenerated file from postgres `errcodes.txt`

/// A SQLSTATE error code
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct SqlState(Inner);

impl SqlState {
    /// Create new `SqlState` from error code
    pub fn from_code(s: &str) -> SqlState {
        match SQLSTATE_MAP.get(s) {
            Some(state) => state.clone(),
            None => SqlState(Inner::Other(s.into())),
        }
    }

    /// Returns the error code corresponding to the `SqlState`
    pub fn code(&self) -> &str {
        match &self.0 {"
        )?;
        self.errcodes.iter().map(|e|e.sqlstate).try_for_each(|s|write!(writer, "
            Inner::E{s} => \"{s}\","
        ))?;
        writer.write_all(b"
            Inner::Other(code) => code,
        }
    }")?;
        self.errcodes.iter().map(|e|(e.sqlstate,e.name)).try_for_each(|(s,n)|write!(writer, "
    /// {s}
    pub const {n}: SqlState = SqlState(Inner::E{s});"
        ))?;
        writer.write_all(b"\
}

#[derive(PartialEq, Eq, Clone, Debug)]
#[allow(clippy::upper_case_acronyms)]
enum Inner {")?;

        self.errcodes.iter().map(|e|e.sqlstate).try_for_each(|s|write!(writer, "
    E{s},"
        ))?;
        writer.write_all(b"
    Other(Box<str>)
}

static SQLSTATE_MAP: phf::Map<&'static str, SqlState> = ")?;

        let mut map = phf_codegen::Map::new();
        for ErrCode { sqlstate, name, .. } in &self.errcodes {
            map.entry(sqlstate, &format!("SqlState::{name}"));
        }
        write!(writer, "{};\n", map.build())?;

        Ok(())
    }
}


